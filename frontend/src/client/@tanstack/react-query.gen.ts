// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query'

import { client } from '../client.gen'
import {
  getHistory,
  getModels,
  getModelStatus,
  getModerationStatus,
  healthCheck,
  type Options,
  root,
  switchModel,
  toggleModeration,
} from '../sdk.gen'
import type {
  GetHistoryData,
  GetHistoryError,
  GetHistoryResponse,
  GetModelsData,
  GetModelsResponse,
  GetModelStatusData,
  GetModelStatusResponse,
  GetModerationStatusData,
  GetModerationStatusResponse,
  HealthCheckData,
  RootData,
  SwitchModelData,
  SwitchModelError,
  SwitchModelResponse2,
  ToggleModerationData,
  ToggleModerationError,
  ToggleModerationResponse,
} from '../types.gen'

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string
    _infinite?: boolean
    tags?: ReadonlyArray<string>
  },
]

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0]
  if (infinite) {
    params._infinite = infinite
  }
  if (tags) {
    params.tags = tags
  }
  if (options?.body) {
    params.body = options.body
  }
  if (options?.headers) {
    params.headers = options.headers
  }
  if (options?.path) {
    params.path = options.path
  }
  if (options?.query) {
    params.query = options.query
  }
  return [params]
}

export const rootQueryKey = (options?: Options<RootData>) =>
  createQueryKey('root', options)

/**
 * Root
 *
 * Health check endpoint.
 */
export const rootOptions = (options?: Options<RootData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof rootQueryKey>>(
    {
      queryFn: async ({ queryKey, signal }) => {
        const { data } = await root({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: rootQueryKey(options),
    },
  )

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) =>
  createQueryKey('healthCheck', options)

/**
 * Health Check
 *
 * Detailed health check.
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) =>
  queryOptions<
    unknown,
    DefaultError,
    unknown,
    ReturnType<typeof healthCheckQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: healthCheckQueryKey(options),
  })

export const getModelsQueryKey = (options?: Options<GetModelsData>) =>
  createQueryKey('getModels', options)

/**
 * List available models
 *
 * List available speech-to-text models.
 *
 * Currently only Zipformer is available - a real-time streaming model
 * optimized for Vietnamese speech recognition (trained on 6000h of data).
 *
 * Note: Model switching is not supported as there is only one model.
 */
export const getModelsOptions = (options?: Options<GetModelsData>) =>
  queryOptions<
    GetModelsResponse,
    DefaultError,
    GetModelsResponse,
    ReturnType<typeof getModelsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getModels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getModelsQueryKey(options),
  })

export const getHistoryQueryKey = (options?: Options<GetHistoryData>) =>
  createQueryKey('getHistory', options)

/**
 * Get transcription history
 *
 * Get transcription history with filtering and pagination.
 *
 * - **page**: Page number (1-indexed)
 * - **limit**: Number of items per page (max 100)
 * - **search**: Search in transcription content
 * - **model**: Filter by model ID
 * - **min_latency/max_latency**: Filter by latency range
 * - **start_date/end_date**: Filter by date range
 */
export const getHistoryOptions = (options?: Options<GetHistoryData>) =>
  queryOptions<
    GetHistoryResponse,
    GetHistoryError,
    GetHistoryResponse,
    ReturnType<typeof getHistoryQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHistory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getHistoryQueryKey(options),
  })

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = { ...queryKey[0] }
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    }
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    }
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    }
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    }
  }
  return params as unknown as typeof page
}

export const getHistoryInfiniteQueryKey = (
  options?: Options<GetHistoryData>,
): QueryKey<Options<GetHistoryData>> =>
  createQueryKey('getHistory', options, true)

/**
 * Get transcription history
 *
 * Get transcription history with filtering and pagination.
 *
 * - **page**: Page number (1-indexed)
 * - **limit**: Number of items per page (max 100)
 * - **search**: Search in transcription content
 * - **model**: Filter by model ID
 * - **min_latency/max_latency**: Filter by latency range
 * - **start_date/end_date**: Filter by date range
 */
export const getHistoryInfiniteOptions = (options?: Options<GetHistoryData>) =>
  infiniteQueryOptions<
    GetHistoryResponse,
    GetHistoryError,
    InfiniteData<GetHistoryResponse>,
    QueryKey<Options<GetHistoryData>>,
    | number
    | Pick<
        QueryKey<Options<GetHistoryData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetHistoryData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getHistory({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getHistoryInfiniteQueryKey(options),
    },
  )

/**
 * Switch active model (deprecated)
 *
 * Switch active model (DEPRECATED).
 *
 * This endpoint is deprecated as only Zipformer model is available.
 * The model is automatically loaded when needed.
 *
 * For backward compatibility, this endpoint still works but only accepts "zipformer".
 *
 * @deprecated
 */
export const switchModelMutation = (
  options?: Partial<Options<SwitchModelData>>,
): UseMutationOptions<
  SwitchModelResponse2,
  SwitchModelError,
  Options<SwitchModelData>
> => {
  const mutationOptions: UseMutationOptions<
    SwitchModelResponse2,
    SwitchModelError,
    Options<SwitchModelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await switchModel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getModelStatusQueryKey = (options?: Options<GetModelStatusData>) =>
  createQueryKey('getModelStatus', options)

/**
 * Get model status
 *
 * Get the status of the currently loaded model.
 */
export const getModelStatusOptions = (options?: Options<GetModelStatusData>) =>
  queryOptions<
    GetModelStatusResponse,
    DefaultError,
    GetModelStatusResponse,
    ReturnType<typeof getModelStatusQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getModelStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getModelStatusQueryKey(options),
  })

export const getModerationStatusQueryKey = (
  options?: Options<GetModerationStatusData>,
) => createQueryKey('getModerationStatus', options)

/**
 * Get content moderation status
 *
 * Get the current status of content moderation.
 *
 * Now uses unified span detector (ViSoBERT-HSD-Span) for moderation.
 */
export const getModerationStatusOptions = (
  options?: Options<GetModerationStatusData>,
) =>
  queryOptions<
    GetModerationStatusResponse,
    DefaultError,
    GetModerationStatusResponse,
    ReturnType<typeof getModerationStatusQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getModerationStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getModerationStatusQueryKey(options),
  })

/**
 * Toggle content moderation
 *
 * Enable or disable content moderation.
 *
 * - When enabled: Starts the span detector if not running, enables moderation
 * - When disabled: Keeps span detector running but stops sending moderation results
 *
 * Uses unified span detector (ViSoBERT-HSD-Span) for both span detection and label inference.
 */
export const toggleModerationMutation = (
  options?: Partial<Options<ToggleModerationData>>,
): UseMutationOptions<
  ToggleModerationResponse,
  ToggleModerationError,
  Options<ToggleModerationData>
> => {
  const mutationOptions: UseMutationOptions<
    ToggleModerationResponse,
    ToggleModerationError,
    Options<ToggleModerationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await toggleModeration({
        ...options,
        ...fnOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}
