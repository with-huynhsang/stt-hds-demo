// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client'
import { client } from './client.gen'
import type {
  GetHistoryData,
  GetHistoryErrors,
  GetHistoryResponses,
  GetModelsData,
  GetModelsResponses,
  GetModelStatusData,
  GetModelStatusResponses,
  GetModerationStatusData,
  GetModerationStatusResponses,
  HealthCheckData,
  HealthCheckResponses,
  RootData,
  RootResponses,
  SwitchModelData,
  SwitchModelErrors,
  SwitchModelResponses,
  ToggleModerationData,
  ToggleModerationErrors,
  ToggleModerationResponses,
} from './types.gen'
import {
  zGetHistoryData,
  zGetHistoryResponse,
  zGetModelsData,
  zGetModelsResponse,
  zGetModelStatusData,
  zGetModelStatusResponse,
  zGetModerationStatusData,
  zGetModerationStatusResponse,
  zHealthCheckData,
  zRootData,
  zSwitchModelData,
  zSwitchModelResponse2,
  zToggleModerationData,
  zToggleModerationResponse,
} from './zod.gen'

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>
}

/**
 * Root
 *
 * Health check endpoint.
 */
export const root = <ThrowOnError extends boolean = false>(
  options?: Options<RootData, ThrowOnError>,
) =>
  (options?.client ?? client).get<RootResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zRootData.parseAsync(data),
    url: '/',
    ...options,
  })

/**
 * Health Check
 *
 * Detailed health check.
 */
export const healthCheck = <ThrowOnError extends boolean = false>(
  options?: Options<HealthCheckData, ThrowOnError>,
) =>
  (options?.client ?? client).get<HealthCheckResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zHealthCheckData.parseAsync(data),
    url: '/health',
    ...options,
  })

/**
 * List available models
 *
 * List available speech-to-text models.
 *
 * Currently only Zipformer is available - a real-time streaming model
 * optimized for Vietnamese speech recognition (trained on 6000h of data).
 *
 * Note: Model switching is not supported as there is only one model.
 */
export const getModels = <ThrowOnError extends boolean = false>(
  options?: Options<GetModelsData, ThrowOnError>,
) =>
  (options?.client ?? client).get<GetModelsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetModelsData.parseAsync(data),
    responseValidator: async (data) =>
      await zGetModelsResponse.parseAsync(data),
    url: '/api/v1/models',
    ...options,
  })

/**
 * Get transcription history
 *
 * Get transcription history with filtering and pagination.
 *
 * - **page**: Page number (1-indexed)
 * - **limit**: Number of items per page (max 100)
 * - **search**: Search in transcription content
 * - **model**: Filter by model ID
 * - **min_latency/max_latency**: Filter by latency range
 * - **start_date/end_date**: Filter by date range
 */
export const getHistory = <ThrowOnError extends boolean = false>(
  options?: Options<GetHistoryData, ThrowOnError>,
) =>
  (options?.client ?? client).get<
    GetHistoryResponses,
    GetHistoryErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => await zGetHistoryData.parseAsync(data),
    responseValidator: async (data) =>
      await zGetHistoryResponse.parseAsync(data),
    url: '/api/v1/history',
    ...options,
  })

/**
 * Switch active model (deprecated)
 *
 * Switch active model (DEPRECATED).
 *
 * This endpoint is deprecated as only Zipformer model is available.
 * The model is automatically loaded when needed.
 *
 * For backward compatibility, this endpoint still works but only accepts "zipformer".
 *
 * @deprecated
 */
export const switchModel = <ThrowOnError extends boolean = false>(
  options: Options<SwitchModelData, ThrowOnError>,
) =>
  (options.client ?? client).post<
    SwitchModelResponses,
    SwitchModelErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => await zSwitchModelData.parseAsync(data),
    responseValidator: async (data) =>
      await zSwitchModelResponse2.parseAsync(data),
    url: '/api/v1/models/switch',
    ...options,
  })

/**
 * Get model status
 *
 * Get the status of the currently loaded model.
 */
export const getModelStatus = <ThrowOnError extends boolean = false>(
  options?: Options<GetModelStatusData, ThrowOnError>,
) =>
  (options?.client ?? client).get<
    GetModelStatusResponses,
    unknown,
    ThrowOnError
  >({
    requestValidator: async (data) =>
      await zGetModelStatusData.parseAsync(data),
    responseValidator: async (data) =>
      await zGetModelStatusResponse.parseAsync(data),
    url: '/api/v1/models/status',
    ...options,
  })

/**
 * Get content moderation status
 *
 * Get the current status of content moderation.
 *
 * Now uses unified span detector (ViSoBERT-HSD-Span) for moderation.
 */
export const getModerationStatus = <ThrowOnError extends boolean = false>(
  options?: Options<GetModerationStatusData, ThrowOnError>,
) =>
  (options?.client ?? client).get<
    GetModerationStatusResponses,
    unknown,
    ThrowOnError
  >({
    requestValidator: async (data) =>
      await zGetModerationStatusData.parseAsync(data),
    responseValidator: async (data) =>
      await zGetModerationStatusResponse.parseAsync(data),
    url: '/api/v1/moderation/status',
    ...options,
  })

/**
 * Toggle content moderation
 *
 * Enable or disable content moderation.
 *
 * - When enabled: Starts the span detector if not running, enables moderation
 * - When disabled: Keeps span detector running but stops sending moderation results
 *
 * Uses unified span detector (ViSoBERT-HSD-Span) for both span detection and label inference.
 */
export const toggleModeration = <ThrowOnError extends boolean = false>(
  options?: Options<ToggleModerationData, ThrowOnError>,
) =>
  (options?.client ?? client).post<
    ToggleModerationResponses,
    ToggleModerationErrors,
    ThrowOnError
  >({
    requestValidator: async (data) =>
      await zToggleModerationData.parseAsync(data),
    responseValidator: async (data) =>
      await zToggleModerationResponse.parseAsync(data),
    url: '/api/v1/moderation/toggle',
    ...options,
  })
